name: Auto-merge Manus PRs when checks are green (squash)

on:
  workflow_run:
    workflows:
      - CI
      - CodeQL
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  merge:
    runs-on: ubuntu-latest

    steps:
      - name: Merge Manus PR if checks succeeded (SHA fallback)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (run.conclusion !== "success") {
              core.info("Workflow concluded as: " + run.conclusion + ". Not merging.");
              return;
            }

            async function getAssociatedPRNumbers() {
              const prs = run.pull_requests || [];
              if (prs.length > 0) return prs.map(p => p.number);

              const sha = run.head_sha;
              if (!sha) return [];

              try {
                const res = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: sha,
                  mediaType: { previews: ["groot"] }
                });
                return (res.data || []).map(pr => pr.number);
              } catch (e) {
                core.warning("Failed to find PR by SHA: " + String(e.message || e));
                return [];
              }
            }

            const prNumbers = await getAssociatedPRNumbers();
            if (prNumbers.length === 0) {
              core.info("No PR associated to this workflow_run.");
              return;
            }

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const maxAttempts = 12;
            const waitMs = 5000;

            for (const prNumber of prNumbers) {
              let pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

              const headRef = pr.data.head.ref || "";
              if (!headRef.startsWith("manus/")) {
                core.info("PR #" + prNumber + " is not manus/* (" + headRef + "). Skipping.");
                continue;
              }

              if (pr.data.state !== "open" || pr.data.draft) {
                core.info("PR #" + prNumber + " not ready (state=" + pr.data.state + ", draft=" + pr.data.draft + ").");
                continue;
              }

              if (pr.data.merged) {
                core.info("PR #" + prNumber + " already merged.");
                continue;
              }

              let ready = false;

              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

                const mergeable = pr.data.mergeable;
                const mergeableState = pr.data.mergeable_state;

                core.info(
                  "PR #" + prNumber +
                  " attempt " + attempt + "/" + maxAttempts +
                  " mergeable=" + mergeable +
                  " state=" + mergeableState
                );

                if (mergeable === true && mergeableState === "clean") {
                  ready = true;
                  break;
                }

                if (mergeableState === "dirty") {
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: prNumber,
                    body: "Auto-merge NOT executed: PR has conflicts (mergeable_state=dirty)."
                  }).catch(() => {});
                  break;
                }

                await sleep(waitMs);
              }

              if (!ready) {
                core.info("PR #" + prNumber + " not ready for merge.");
                continue;
              }

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prNumber,
                  merge_method: "squash",
                  sha: pr.data.head.sha
                });

                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber,
                  body: "Auto-merge executed (squash). Triggered by workflow: " + run.name + "\nRun: " + run.html_url
                }).catch(() => {});

                core.info("Merged PR #" + prNumber + " (squash).");
              } catch (e) {
                const msg = String(e.message || e);

                core.warning("Merge failed for PR #" + prNumber + ": " + msg);

                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber,
                  body: "Tried auto-merge (squash), but it failed.\nError: " + msg + "\nIf checks are green, merge manually."
                }).catch(() => {});
              }
            }
