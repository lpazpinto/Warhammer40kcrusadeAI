name: Auto-merge Manus PRs when checks are green (squash)

on:
  workflow_run:
    workflows: ["CI", "CodeQL"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto_merge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge Manus PRs when checks are green (squash)
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Só tenta merge quando o workflow terminou com sucesso
            if (run.conclusion !== "success") {
              core.info(`Workflow ${run.name} concluiu como ${run.conclusion}. Não tentando merge.`);
              return;
            }

            async function getAssociatedPRNumbers() {
              // 1) Caso o payload já venha com PRs
              const prs = run.pull_requests || [];
              if (prs.length > 0) return prs.map(p => p.number);

              // 2) Fallback por SHA
              const sha = run.head_sha;
              if (!sha) return [];

              try {
                const { data } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: sha,
                  mediaType: { previews: ["groot"] },
                });

                return (data || []).map(pr => pr.number);
              } catch (e) {
                core.warning(`Falha ao buscar PR por SHA (${sha}): ${String(e?.message || e)}`);
                return [];
              }
            }

            const prNumbers = await getAssociatedPRNumbers();
            if (prNumbers.length === 0) {
              core.info("Nenhum PR associado a este workflow_run (nem por SHA).");
              return;
            }

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const maxAttempts = 36;   // ~3 minutos
            const waitMs = 5000;

            for (const prNumber of prNumbers) {
              // Carrega PR
              const { data: prInitial } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

              const headRef = prInitial.head?.ref || "";
              if (!headRef.startsWith("manus/")) {
                core.info(`PR #${prNumber} não é manus/* (${headRef}). Ignorando.`);
                continue;
              }

              if (prInitial.state !== "open" || prInitial.draft) {
                core.info(`PR #${prNumber} não está pronto (state=${prInitial.state}, draft=${prInitial.draft}).`);
                continue;
              }

              if (prInitial.merged) {
                core.info(`PR #${prNumber} já está merged.`);
                continue;
              }

              // Espera o GitHub calcular mergeable_state corretamente
              let ready = false;
              let latestPR = prInitial;

              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                latestPR = pr;

                const mergeableState = pr.mergeable_state; // clean/blocked/dirty/unknown/unstable
                const mergeable = pr.mergeable;

                core.info(`PR #${prNumber} tentativa ${attempt}/${maxAttempts}: mergeable=${mergeable}, state=${mergeableState}`);

                if (mergeable === true && mergeableState === "clean") {
                  ready = true;
                  break;
                }

                if (mergeableState === "dirty") {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: prNumber,
                    body: "❌ Auto-merge NÃO realizado: PR com conflitos (mergeable_state=dirty)."
                  }).catch(() => {});
                  break;
                }

                await sleep(waitMs);
              }

              if (!ready) {
                core.info(`PR #${prNumber} ainda não está pronto para merge.`);
                continue;
              }

              // Faz merge squash
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prNumber,
                  merge_method: "squash",
                  sha: latestPR.head.sha
                });

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `✅ Auto-merge executado (SQUASH) após checks verdes.\nWorkflow: **${run.name}**\nRun: ${run.html_url}`
                }).catch(() => {});

                core.info(`Merged PR #${prNumber} (squash).`);
              } catch (e) {
                const msg = String(e?.message || e);
                core.warning(`Falha ao fazer merge do PR #${prNumber}: ${msg}`);

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `❌ Tentei fazer auto-merge (squash), mas falhou.\nErro: \`${msg}\`\nSe estiver tudo verde, você pode dar merge manualmente.`
                }).catch(() => {});
              }
