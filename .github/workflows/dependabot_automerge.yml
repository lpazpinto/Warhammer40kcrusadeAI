name: Dependabot Auto-merge (safe)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: dependabot-automerge-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  automerge:
    # Roda apenas para PRs cujo autor é o Dependabot.
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Fetch Dependabot metadata
        id: meta
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge (squash) when checks are green
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;

            const updateType = "${{ steps.meta.outputs.update-type }}";
            const safeTypes = new Set([
              "security-update",
              "version-update:semver-patch",
              "version-update:semver-minor",
            ]);

            if (!safeTypes.has(updateType)) {
              core.info(`Skip: update-type=${updateType} (not safe).`);
              return;
            }

            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            async function getPR() {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return data;
            }

            async function getCheckRuns(sha) {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: sha,
                per_page: 100,
              });
              return data.check_runs || [];
            }

            // IMPORTANT: Em GitHub Actions, o check-run costuma ter como "name" o nome do JOB.
            // No seu caso ele aparece como "... / automerge (pull_request_target)", então o name tende a ser "automerge".
            // Se a gente não ignorar o próprio check-run, dá deadlock: sempre vai existir 1 pending (ele mesmo).
            const currentRunId = process.env.GITHUB_RUN_ID;
            const currentJob = (process.env.GITHUB_JOB || "").toLowerCase();

            function isOwnCheckRun(cr) {
              const name = (cr.name || "").toLowerCase();

              // 1) Match pelo job id (geralmente igual ao check-run name)
              if (currentJob && name === currentJob) return true;

              // 2) Match por URL do run atual
              if (cr.details_url && currentRunId && cr.details_url.includes(`/actions/runs/${currentRunId}`)) return true;

              // 3) Fallback por texto (caso GH mude o name)
              if (name.includes("dependabot auto-merge")) return true;

              return false;
            }

            function isOkConclusion(conclusion) {
              return ["success", "neutral", "skipped"].includes(conclusion);
            }

            // Espera curta só para os checks TERMINAREM (se já terminou, sai na primeira tentativa)
            const maxAttempts = 20; // ~5 min
            const waitMs = 15000;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const pr = await getPR();

              const mergeable = pr.mergeable;
              const mergeableState = pr.mergeable_state;
              const sha = pr.head.sha;

              const checkRuns = await getCheckRuns(sha);
              const relevant = checkRuns.filter((cr) => !isOwnCheckRun(cr));

              const pending = relevant.filter((cr) => cr.status !== "completed");
              const failed = relevant.filter((cr) => cr.status === "completed" && !isOkConclusion(cr.conclusion));

              core.info(
                `Attempt ${attempt}/${maxAttempts}: mergeable=${mergeable} state=${mergeableState} | ` +
                `checks: total=${relevant.length} pending=${pending.length} failed=${failed.length}`
              );

              if (mergeableState === "dirty") {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber,
                  body: "❌ Dependabot auto-merge bloqueado: PR com conflitos (mergeable_state=dirty).",
                }).catch(() => {});
                return;
              }

              // Não exige mergeable_state=clean porque ele pode ficar "unstable" por causa de checks não-requeridos.
              if (pending.length === 0 && failed.length === 0 && mergeable === true) {
                break;
              }

              if (attempt === maxAttempts) {
                core.info("Checks/mergeable ainda não prontos. Vou sair sem habilitar auto-merge.");
                return;
              }

              await sleep(waitMs);
            }

            // Aprova PR (caso branch protection exija review)
            await github.rest.pulls.createReview({
              owner, repo,
              pull_number: prNumber,
              event: "APPROVE",
              body: "✅ Auto-approval via GitHub Actions (Dependabot safe update).",
            }).catch(() => {});

            // Habilita auto-merge (SQUASH)
            const pr = await getPR();
            const mutation = `
              mutation($pullRequestId: ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {
                  pullRequest { number }
                }
              }
            `;

            try {
              await github.graphql(mutation, { pullRequestId: pr.node_id });
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `✅ Auto-merge habilitado (SQUASH) para update seguro do Dependabot.\nupdate-type: \`${updateType}\``
              }).catch(() => {});
              core.info("Auto-merge enabled.");
            } catch (e) {
              core.warning(`Falha ao habilitar auto-merge: ${String(e?.message || e)}`);
            }
