name: Dependabot Auto-merge (safe)

on:
  check_suite:
    types: [completed]
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

concurrency:
  group: dependabot-automerge-${{ github.event.check_suite.head_sha || github.run_id }}
  cancel-in-progress: true

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - name: Try squash-merge Dependabot PRs when clean
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const sha = context.payload.check_suite?.head_sha;
            if (!sha) {
              core.info("Sem head_sha no payload (check_suite). Saindo.");
              return;
            }

            // Busca PRs associados ao commit SHA
            async function getAssociatedPRs(commitSha) {
              try {
                const { data } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: commitSha,
                  mediaType: { previews: ["groot"] }
                });
                return data || [];
              } catch (e) {
                core.warning(`Falha ao buscar PRs associados ao SHA ${commitSha}: ${String(e?.message || e)}`);
                return [];
              }
            }

            function isDependabotPR(pr) {
              const login = pr?.user?.login || "";
              const headRef = pr?.head?.ref || "";
              return login === "dependabot[bot]" || headRef.startsWith("dependabot/");
            }

            // Lê check-runs (GitHub Actions, CodeQL, etc.) do SHA
            async function getCheckRuns(commitSha) {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: commitSha,
                per_page: 100
              });
              return data?.check_runs || [];
            }

            // Lê commit status agregado (alguns providers ainda usam status API)
            async function getCombinedStatus(commitSha) {
              try {
                const { data } = await github.rest.repos.getCombinedStatusForRef({
                  owner,
                  repo,
                  ref: commitSha
                });
                return data;
              } catch (e) {
                core.warning(`Falha ao ler combined status do SHA ${commitSha}: ${String(e?.message || e)}`);
                return null;
              }
            }

            const prs = await getAssociatedPRs(sha);
            if (!prs.length) {
              core.info(`Nenhum PR associado ao SHA ${sha}. Saindo.`);
              return;
            }

            // Carrega check-runs / statuses uma vez (por SHA)
            const allCheckRuns = await getCheckRuns(sha);
            const combinedStatus = await getCombinedStatus(sha);

            // Remove o próprio workflow de automerge da lista de checks (para não "esperar por si mesmo")
            const checkRuns = allCheckRuns.filter(cr => {
              const n = (cr.name || "").toLowerCase();
              return !n.includes("dependabot auto-merge") && !n.includes("dependabot-automerge");
            });

            // Gate 1: ainda tem coisa rodando?
            const inProgress = checkRuns.filter(cr => cr.status !== "completed");
            if (inProgress.length) {
              core.info(`Ainda existem checks em execução para ${sha}: ${inProgress.map(x => x.name).join(", ")}. Vou tentar novamente no próximo check_suite completed.`);
              return;
            }

            // Gate 2: algum check falhou?
            const badConclusions = new Set(["failure", "cancelled", "timed_out", "action_required"]);
            const failed = checkRuns.filter(cr => badConclusions.has(cr.conclusion));
            if (failed.length) {
              core.info(`Checks falharam para ${sha}: ${failed.map(x => `${x.name}=${x.conclusion}`).join(", ")}. Não vou mergear.`);
              return;
            }

            // Gate 3: CodeQL NUNCA pode ser neutral/skipped
            const nonSuccessCodeQL = checkRuns.filter(cr => {
              const name = (cr.name || "").toLowerCase();
              return name.includes("codeql") && cr.conclusion !== "success";
            });
            if (nonSuccessCodeQL.length) {
              core.info(`CodeQL não está SUCCESS para ${sha}: ${nonSuccessCodeQL.map(x => `${x.name}=${x.conclusion}`).join(", ")}. Bloqueando merge.`);
              return;
            }

            // Gate 4: statuses agregados (se existirem) também precisam estar success
            if (combinedStatus && combinedStatus.state && combinedStatus.state !== "success") {
              core.info(`Combined status do SHA ${sha} não é success (state=${combinedStatus.state}). Bloqueando merge.`);
              return;
            }

            // Agora sim: tentar merge em cada PR dependabot associado
            for (const pr of prs) {
              if (!isDependabotPR(pr)) {
                core.info(`PR #${pr.number} não é Dependabot. Ignorando.`);
                continue;
              }

              if (pr.state !== "open" || pr.draft) {
                core.info(`PR #${pr.number} não está pronto (state=${pr.state}, draft=${pr.draft}). Ignorando.`);
                continue;
              }

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: "squash",
                  sha
                });

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: `✅ Dependabot auto-merge (squash) executado.\nSHA: ${sha}\nTrigger: check_suite completed`
                }).catch(() => {});
                
                core.info(`Merged PR #${pr.number} (squash).`);
              } catch (e) {
                const msg = String(e?.message || e);
                core.warning(`Falha ao mergear PR #${pr.number}: ${msg}`);

                // Não falha o job: apenas comenta (opcional)
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: `⚠️ Tentei fazer auto-merge (squash), mas não foi possível.\nErro: \`${msg}\`\nSe o GitHub exigir branch up-to-date ou houver regra extra, pode ser necessário "Update branch" / rebase.`
                }).catch(() => {});
              }
            }
