name: Dependabot Auto-merge (safe)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

concurrency:
  group: dependabot-automerge-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  automerge:
    # Garante que roda apenas para PRs cujo autor é o Dependabot,
    # mesmo que o evento seja disparado por outra conta (ex.: reruns/edições).
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Fetch Dependabot metadata
        id: meta
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge (squash) when checks are green
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;

            const updateType = "${{ steps.meta.outputs.update-type }}";
            const safeTypes = new Set([
              "security-update",
              "version-update:semver-patch",
              "version-update:semver-minor",
            ]);

            if (!safeTypes.has(updateType)) {
              core.info(`Skip: update-type=${updateType} (not safe).`);
              return;
            }

            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            async function getPR() {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return data;
            }

            async function getCheckRuns(sha) {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: sha,
                per_page: 100,
              });
              return data.check_runs || [];
            }

            function isOwnCheckRun(cr) {
              const name = (cr.name || "").toLowerCase();
              // Evita deadlock: não espere pelo próprio job/workflow
              return name.includes("dependabot auto-merge") || name.includes("enable auto-merge");
            }

            function isOkConclusion(conclusion) {
              return ["success", "neutral", "skipped"].includes(conclusion);
            }

            const maxAttempts = 40;      // ~20 min
            const waitMs = 30000;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const pr = await getPR();

              // mergeable_state pode vir null/unknown no começo
              const mergeable = pr.mergeable;
              const mergeableState = pr.mergeable_state;

              const sha = pr.head.sha;
              const checkRuns = await getCheckRuns(sha);
              const relevant = checkRuns.filter((cr) => !isOwnCheckRun(cr));

              const pending = relevant.filter((cr) => cr.status !== "completed");
              const failed = relevant.filter((cr) => cr.status === "completed" && !isOkConclusion(cr.conclusion));

              core.info(
                `Attempt ${attempt}/${maxAttempts}: mergeable=${mergeable} state=${mergeableState} | ` +
                `checks: total=${relevant.length} pending=${pending.length} failed=${failed.length}`
              );

              if (mergeableState === "dirty") {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber,
                  body: "❌ Dependabot auto-merge bloqueado: PR com conflitos (mergeable_state=dirty).",
                }).catch(() => {});
                return;
              }

              if (pending.length === 0 && failed.length === 0 && mergeable === true && mergeableState === "clean") {
                break;
              }

              if (attempt === maxAttempts) {
                core.info("Checks/mergeable ainda não prontos. Vou sair sem habilitar auto-merge.");
                return;
              }

              await sleep(waitMs);
            }

            // Aprova PR (caso branch protection exija review)
            await github.rest.pulls.createReview({
              owner, repo,
              pull_number: prNumber,
              event: "APPROVE",
              body: "✅ Auto-approval via GitHub Actions (Dependabot safe update).",
            }).catch(() => {});

            // Habilita auto-merge (SQUASH)
            const pr = await getPR();
            const mutation = `
              mutation($pullRequestId: ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {
                  pullRequest { number }
                }
              }
            `;

            try {
              await github.graphql(mutation, { pullRequestId: pr.node_id });
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `✅ Auto-merge habilitado (SQUASH) para update seguro do Dependabot.\nupdate-type: \`${updateType}\``,
              }).catch(() => {});
              core.info("Auto-merge enabled.");
            } catch (e) {
              core.warning(`Falha ao habilitar auto-merge: ${String(e?.message || e)}`);
              // Não dá hard-fail pra não ficar vermelho por nada
            }
