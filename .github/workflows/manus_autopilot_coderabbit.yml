name: Manus Autopilot (coderabbit - debounced 15m)

on:
  pull_request_review:
    types: [submitted, edited]
  pull_request_review_comment:
    types: [created, edited]
  issue_comment:
    types: [created, edited]

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  debounce_and_trigger:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # âœ… Debounce por PR (cancela run anterior se chegar outro evento do CodeRabbit)
    concurrency:
      group: coderabbit-debounce-${{ github.repository }}-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
      cancel-in-progress: true

    steps:
      - name: Capture PR number + event timestamp (only CodeRabbit)
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber = null;
            let author = null;
            let eventIso = null;

            if (context.eventName === "pull_request_review") {
              prNumber = context.payload.pull_request?.number;
              author = context.payload.review?.user?.login;
              eventIso = context.payload.review?.submitted_at || context.payload.review?.submittedAt;
            } else if (context.eventName === "pull_request_review_comment") {
              prNumber = context.payload.pull_request?.number;
              author = context.payload.comment?.user?.login;
              eventIso = context.payload.comment?.updated_at || context.payload.comment?.created_at;
            } else if (context.eventName === "issue_comment") {
              if (!context.payload.issue?.pull_request) {
                core.setOutput("should_run", "false");
                return;
              }
              prNumber = context.payload.issue?.number;
              author = context.payload.comment?.user?.login;
              eventIso = context.payload.comment?.updated_at || context.payload.comment?.created_at;
            } else {
              core.setOutput("should_run", "false");
              return;
            }

            const login = (author || "").toLowerCase();
            const isCodeRabbit =
              login === "coderabbitai" ||
              login === "coderabbitai[bot]" ||
              login.includes("coderabbit");

            if (!isCodeRabbit || !prNumber) {
              core.setOutput("should_run", "false");
              return;
            }

            // fallback seguro
            if (!eventIso) eventIso = new Date().toISOString();

            core.setOutput("should_run", "true");
            core.setOutput("pr_number", String(prNumber));
            core.setOutput("event_iso", String(eventIso));

      - name: Wait 15 minutes (debounce)
        if: steps.meta.outputs.should_run == 'true'
        run: sleep 900

      - name: Trigger Manus only if actionable NEW CodeRabbit feedback exists
        if: steps.meta.outputs.should_run == 'true'
        uses: actions/github-script@v7
        env:
          MANUS_API_KEY: ${{ secrets.MANUS_API_KEY }}
          MANUS_PROJECT_ID: ${{ secrets.MANUS_PROJECT_ID }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const prNumber = Number("${{ steps.meta.outputs.pr_number }}");
            const eventIso = "${{ steps.meta.outputs.event_iso }}";

            const busyLabel = "manus-busy";
            const markerPrefix = "<!-- manus-autopilot:coderabbit_last_processed=";

            function isCodeRabbitLogin(login) {
              const l = String(login || "").toLowerCase();
              return l === "coderabbitai" || l === "coderabbitai[bot]" || l.includes("coderabbit");
            }

            // âœ… Actionable = contÃ©m sinais de recomendaÃ§Ã£o/sugestÃ£o/issue, NÃƒO apenas walkthrough
            function isActionable(text) {
              if (!text) return false;
              const raw = String(text).trim();
              if (raw.length < 160) return false;

              const t = raw.toLowerCase();

              // placeholders / "reviewing..."
              const placeholder = [
                /review in progress/i,
                /i['â€™]?m reviewing/i,
                /starting (my )?review/i,
                /generating review/i,
                /analyzing/i,
                /please wait/i,
                /working on it/i
              ];
              if (placeholder.some(re => re.test(raw))) return false;

              // Se tiver sÃ³ walkthrough sem sinais de "suggestions/issues/nitpick", ignora
              const hasWalkthroughOnly =
                t.includes("walkthrough") &&
                !t.includes("suggest") &&
                !t.includes("nitpick") &&
                !t.includes("issue") &&
                !t.includes("recommend") &&
                !t.includes("should") &&
                !t.includes("fix") &&
                !t.includes("security") &&
                !t.includes("performance");

              if (hasWalkthroughOnly) return false;

              const actionableMarkers = [
                "suggestion",
                "suggestions",
                "nitpick",
                "issues",
                "issue",
                "recommended",
                "recommendation",
                "should",
                "fix",
                "bug",
                "security",
                "vulnerability",
                "performance",
                "warning",
                "error"
              ];

              const hasMarker = actionableMarkers.some(m => t.includes(m));

              // tambÃ©m conta ter blocos de cÃ³digo (geralmente contÃ©m patch/trecho)
              const hasCodeBlock = raw.includes("```");

              return hasMarker || (hasCodeBlock && raw.length >= 250);
            }

            function isNewEnough(iso) {
              // SÃ³ processa comentÃ¡rios criados/atualizados depois do evento que iniciou o debounce.
              try {
                return new Date(iso).getTime() >= new Date(eventIso).getTime();
              } catch {
                return false;
              }
            }

            // 1) Carrega PR
            const prResp = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const pr = prResp.data;

            const headRef = pr.head?.ref || "";
            if (!headRef.startsWith("manus/")) {
              core.info(`PR #${prNumber} nÃ£o Ã© manus/* (${headRef}). Ignorando.`);
              return;
            }

            if (pr.state !== "open" || pr.draft) {
              core.info(`PR #${prNumber} nÃ£o estÃ¡ pronto (state=${pr.state}, draft=${pr.draft}).`);
              return;
            }

            const labels = (pr.labels || []).map(l => l.name);
            if (labels.includes(busyLabel)) {
              core.info(`PR #${prNumber} estÃ¡ busy (${busyLabel}). NÃ£o criando task nova agora.`);
              return;
            }

            if (!process.env.MANUS_API_KEY) {
              core.warning("MANUS_API_KEY nÃ£o configurada nos Secrets.");
              return;
            }

            // 2) Busca comments do PR (issues comments)
            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number: prNumber, per_page: 100
            });

            // Marker do Ãºltimo processamento (comentÃ¡rio do prÃ³prio autopilot)
            let lastProcessedId = null;
            for (const c of issueComments) {
              const body = String(c.body || "");
              const idx = body.indexOf(markerPrefix);
              if (idx >= 0) {
                const rest = body.slice(idx + markerPrefix.length);
                const end = rest.indexOf("-->");
                if (end > 0) {
                  lastProcessedId = rest.slice(0, end).trim();
                }
              }
            }

            // 3) Agrega feedback do CodeRabbit (issue comments + review comments + reviews)
            const codeRabbitIssueComments = issueComments
              .filter(c => isCodeRabbitLogin(c.user?.login))
              .map(c => ({
                id: String(c.id),
                url: c.html_url,
                body: (c.body || "").trim(),
                updated_at: c.updated_at || c.created_at || ""
              }));

            const reviewComments = await github.paginate(github.rest.pulls.listReviewComments, {
              owner, repo, pull_number: prNumber, per_page: 100
            });

            const codeRabbitReviewComments = reviewComments
              .filter(c => isCodeRabbitLogin(c.user?.login))
              .map(c => ({
                id: String(c.id),
                url: c.html_url,
                body: (c.body || "").trim(),
                updated_at: c.updated_at || c.created_at || ""
              }));

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner, repo, pull_number: prNumber, per_page: 100
            });

            const codeRabbitReviews = reviews
              .filter(r => isCodeRabbitLogin(r.user?.login))
              .map(r => ({
                id: String(r.id),
                url: r.html_url,
                body: (r.body || "").trim(),
                updated_at: r.submitted_at || r.submittedAt || ""
              }));

            const all = [...codeRabbitIssueComments, ...codeRabbitReviewComments, ...codeRabbitReviews]
              .filter(x => x.body && x.updated_at);

            // 4) NOVO: sÃ³ feedback "novo" (>= eventIso) + actionable
            const actionableNew = all
              .filter(x => isNewEnough(x.updated_at))
              .filter(x => isActionable(x.body));

            if (actionableNew.length === 0) {
              core.info("ApÃ³s 15min, nÃ£o encontrei feedback NOVO e ACTIONABLE do CodeRabbit. Nada a fazer.");
              return;
            }

            // Pega o "mais recente" por updated_at
            actionableNew.sort((a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());
            const newest = actionableNew[0];

            // 5) Dedup: se jÃ¡ processamos esse ID, nÃ£o chama de novo
            if (lastProcessedId && String(lastProcessedId) === String(newest.id)) {
              core.info(`Feedback jÃ¡ processado (id=${newest.id}). Evitando re-trigger.`);
              return;
            }

            // 6) Marca busy antes de chamar Manus
            await github.rest.issues.addLabels({
              owner, repo, issue_number: prNumber, labels: [busyLabel]
            }).catch(() => {});

            // Monta resumo (limitado)
            const maxChars = 3500;
            let combined = actionableNew
              .slice(0, 5)
              .map((x, i) => `### Feedback ${i + 1}\nLink: ${x.url}\nUpdated: ${x.updated_at}\n\n${x.body}`)
              .join("\n\n---\n\n");

            if (combined.length > maxChars) combined = combined.slice(0, maxChars) + "\n\n...(truncado)";

            const prompt = [
              "VocÃª Ã© o agente Manus e hÃ¡ feedback NOVO e ACTIONABLE do CodeRabbit neste Pull Request.",
              "",
              `RepositÃ³rio: ${owner}/${repo}`,
              `PR: ${pr.html_url}`,
              `Branch: ${headRef}`,
              `Janela debounce iniciada em: ${eventIso}`,
              "",
              "Resumo do feedback do CodeRabbit (agregado):",
              "```",
              combined,
              "```",
              "",
              "Tarefa:",
              "1) Ler TODO o feedback do CodeRabbit no PR (todas as threads e comentÃ¡rios).",
              "2) Implementar as mudanÃ§as necessÃ¡rias com o MENOR patch possÃ­vel.",
              `3) Fazer push na MESMA branch do PR (${headRef}).`,
              "4) Garantir CI/CodeQL verdes.",
              "5) NÃƒO fazer merge.",
              "",
              "Ao finalizar, comentar no PR:",
              "- o que foi feito",
              "- por que foi feito",
              "- como validar."
            ].join("\n");

            const bodyPayload = {
              prompt,
              agentProfile: "manus-1.6",
              taskMode: "agent",
              interactiveMode: false
            };

            if (process.env.MANUS_PROJECT_ID) {
              bodyPayload.projectId = process.env.MANUS_PROJECT_ID; // camelCase
            }

            // 7) Chama Manus
            const res = await fetch("https://api.manus.ai/v1/tasks", {
              method: "POST",
              headers: {
                "API_KEY": process.env.MANUS_API_KEY,
                "Content-Type": "application/json"
              },
              body: JSON.stringify(bodyPayload)
            });

            if (!res.ok) {
              const text = await res.text();

              // remove busy se falhou
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: prNumber, name: busyLabel
              }).catch(() => {});

              throw new Error(`Manus API error: ${res.status} ${text}`);
            }

            const data = await res.json();

            // 8) ComentÃ¡rio com marker (dedup) + link task
            const marker = `${markerPrefix}${newest.id} -->`;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: [
                `ðŸ¤– **Manus Autopilot (debounced 15m)** acionado apÃ³s feedback NOVO/ACTIONABLE do CodeRabbit.`,
                `Task: ${data.task_url || "(task_url nÃ£o retornado)"}`,
                `Fonte mais recente (id=${newest.id}): ${newest.url}`,
                marker
              ].join("\n")
            }).catch(() => {});
