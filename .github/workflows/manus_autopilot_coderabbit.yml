name: Manus Autopilot (CodeRabbit + Codex)

on:
  issue_comment:
    types: [created, edited]
  pull_request_review_comment:
    types: [created, edited]
  pull_request_review:
    types: [submitted, edited]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  autopilot:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Debounce 15m and trigger Manus only on actionable bot feedback
        uses: actions/github-script@v7
        env:
          MANUS_API_KEY: ${{ secrets.MANUS_API_KEY }}
          MANUS_PROJECT_ID: ${{ secrets.MANUS_PROJECT_ID }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const busyLabel = "manus-busy";
            const pendingLabel = "manus-feedback-pending";

            const allowedBots = new Set([
              "coderabbitai",
              "coderabbitai[bot]",
              "chatgpt-codex-connector",
              "chatgpt-codex-connector[bot]"
            ]);

            function getEventInfo() {
              const p = context.payload;

              // issue_comment em PR
              if (p.comment && p.issue && p.issue.pull_request) {
                return {
                  prNumber: p.issue.number,
                  actor: p.comment.user?.login,
                  body: p.comment.body || "",
                  url: p.comment.html_url || ""
                };
              }

              // review comment
              if (p.comment && p.pull_request) {
                return {
                  prNumber: p.pull_request.number,
                  actor: p.comment.user?.login,
                  body: p.comment.body || "",
                  url: p.comment.html_url || ""
                };
              }

              // review submitted/edited
              if (p.review && p.pull_request) {
                return {
                  prNumber: p.pull_request.number,
                  actor: p.review.user?.login,
                  body: p.review.body || "",
                  url: p.review.html_url || ""
                };
              }

              return null;
            }

            const info = getEventInfo();
            if (!info) {
              core.info("Evento n√£o associado a PR. Ignorando.");
              return;
            }

            if (!allowedBots.has(info.actor)) {
              core.info(`Autor ${info.actor} n√£o √© bot alvo. Ignorando.`);
              return;
            }

            // Carrega PR
            const prResp = await github.rest.pulls.get({ owner, repo, pull_number: info.prNumber });
            const pr = prResp.data;

            const headRef = pr.head?.ref || "";
            if (!headRef.startsWith("manus/")) {
              core.info(`PR #${info.prNumber} n√£o √© manus/* (${headRef}). Ignorando.`);
              return;
            }

            if (pr.state !== "open" || pr.draft) {
              core.info(`PR #${info.prNumber} n√£o est√° pronto (state=${pr.state}, draft=${pr.draft}).`);
              return;
            }

            const labels = (pr.labels || []).map(l => l.name);

            // Se j√° tem busy, n√£o cria nova task (evita flood)
            if (labels.includes(busyLabel)) {
              core.info(`PR #${info.prNumber} j√° est√° ${busyLabel}. Ignorando.`);
              return;
            }

            // Debounce: se j√° tem pending, n√£o cria outro job (ele vai agregar tudo)
            if (labels.includes(pendingLabel)) {
              core.info(`PR #${info.prNumber} j√° est√° ${pendingLabel}. Ignorando para evitar duplicidade.`);
              return;
            }

            // Marca pending
            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: info.prNumber,
              labels: [pendingLabel]
            }).catch(() => {});

            // Espera 15 minutos pra deixar CodeRabbit/Codex terminarem (e capturar coment√°rios editados)
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            core.info("Aguardando 15 minutos para agregar feedback final (debounce)...");
            await sleep(15 * 60 * 1000);

            // Recarrega PR e labels (pode ter mudado)
            const prResp2 = await github.rest.pulls.get({ owner, repo, pull_number: info.prNumber });
            const pr2 = prResp2.data;

            if (pr2.state !== "open" || pr2.draft) {
              core.info("PR fechada/draft ap√≥s debounce. Limpando pending e saindo.");
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            const labels2 = (pr2.labels || []).map(l => l.name);
            if (labels2.includes(busyLabel)) {
              core.info(`PR ficou busy durante debounce. Limpando pending e saindo.`);
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            // Coleta coment√°rios (issue comments + review comments + reviews)
            async function collectBotFeedback(prNumber) {
              const sinceMs = Date.now() - (24 * 60 * 60 * 1000); // √∫ltimas 24h
              const items = [];

              const issueComments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: prNumber, per_page: 100
              });

              for (const c of issueComments) {
                const login = c.user?.login;
                const created = new Date(c.created_at).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({
                  kind: "issue_comment",
                  author: login,
                  url: c.html_url,
                  created_at: c.created_at,
                  body: c.body || ""
                });
              }

              const reviewComments = await github.paginate(github.rest.pulls.listReviewComments, {
                owner, repo, pull_number: prNumber, per_page: 100
              });

              for (const c of reviewComments) {
                const login = c.user?.login;
                const created = new Date(c.created_at).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({
                  kind: "review_comment",
                  author: login,
                  url: c.html_url,
                  created_at: c.created_at,
                  body: c.body || ""
                });
              }

              const reviews = await github.paginate(github.rest.pulls.listReviews, {
                owner, repo, pull_number: prNumber, per_page: 100
              });

              for (const r of reviews) {
                const login = r.user?.login;
                const created = new Date(r.submitted_at || r.created_at || Date.now()).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({
                  kind: "review",
                  author: login,
                  url: r.html_url,
                  created_at: r.submitted_at || r.created_at || "",
                  body: r.body || ""
                });
              }

              // ordena por data e mant√©m os mais recentes
              items.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
              return items.slice(-30);
            }

            function isActionable(text) {
              const t = (text || "").toLowerCase();

              // Ignora placeholders comuns
              const placeholderSignals = [
                "reviewing",
                "i'm reviewing",
                "estou revisando",
                "starting review",
                "in progress",
                "queued"
              ];
              const isLikelyPlaceholder = placeholderSignals.some(s => t.includes(s)) && t.length < 400;
              if (isLikelyPlaceholder) return false;

              // Heur√≠sticas de actionable (Coderabbit/Codex)
              const actionableSignals = [
                "actionable",
                "requested changes",
                "must",
                "should",
                "fix",
                "bug",
                "security",
                "vulnerab",
                "error",
                "pre-merge checks",
                "nitpick",
                "finishing touches",
                "‚ùå",
                "‚ö†"
              ];
              if (actionableSignals.some(s => t.includes(s))) return true;

              // Se tem bastante conte√∫do, assume que √© review real
              if (t.length >= 600) return true;

              return false;
            }

            const feedback = await collectBotFeedback(info.prNumber);

            const actionable = feedback.some(f => isActionable(f.body));

            if (!actionable) {
              core.info("Nenhum feedback actionable detectado. Limpando pending e saindo.");
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            // Marca busy (agora sim)
            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: info.prNumber,
              labels: [busyLabel]
            }).catch(() => {});

            // Monta prompt agregando CodeRabbit + Codex
            const prUrl = pr2.html_url;
            const headRef2 = pr2.head?.ref || "";

            const chunks = feedback.map((f, idx) => {
              const body = (f.body || "").replace(/\r/g, "");
              const clipped = body.length > 2200 ? body.slice(0, 2200) + "\n...(truncado)" : body;
              return [
                `### Feedback ${idx + 1} (${f.author} / ${f.kind})`,
                `Link: ${f.url}`,
                "```",
                clipped,
                "```"
              ].join("\n");
            });

            const prompt = [
              `Voc√™ √© o agente Manus e h√° feedback ACTIONABLE de bots de review neste Pull Request.`,
              ``,
              `Reposit√≥rio: ${owner}/${repo}`,
              `PR: ${prUrl}`,
              `Branch: ${headRef2}`,
              ``,
              `IMPORTANTE: Considere TODO o feedback de:`,
              `- CodeRabbit (coderabbitai)`,
              `- ChatGPT Codex (chatgpt-codex-connector)`,
              ``,
              `Resumo do feedback (agregado; pode haver coment√°rios editados):`,
              "```",
              `Total itens: ${feedback.length}`,
              "```",
              ``,
              ...chunks,
              ``,
              `Tarefa:`,
              `1) Ler TODO o feedback no PR (todas as threads e coment√°rios), incluindo CodeRabbit + Codex.`,
              `2) Implementar as mudan√ßas necess√°rias com o MENOR patch poss√≠vel.`,
              `3) Fazer push na MESMA branch do PR (${headRef2}).`,
              `4) Garantir CI/CodeQL verdes.`,
              `5) N√ÉO fazer merge.`,
              ``,
              `Ao finalizar, comentar no PR:`,
              `- o que foi feito`,
              `- por que foi feito`,
              `- como validar`
            ].join("\n");

            const body = {
              prompt,
              agentProfile: "manus-1.6",
              taskMode: "agent",
              interactiveMode: false
            };

            if (process.env.MANUS_PROJECT_ID) body.projectId = process.env.MANUS_PROJECT_ID;

            let data;
            try {
              const res = await fetch("https://api.manus.ai/v1/tasks", {
                method: "POST",
                headers: {
                  "API_KEY": process.env.MANUS_API_KEY,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });

              if (!res.ok) {
                const text = await res.text();
                throw new Error(`Manus API error: ${res.status} ${text}`);
              }

              data = await res.json();
            } catch (err) {
              // rollback: remove busy e pending, pra n√£o travar
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: busyLabel }).catch(() => {});
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              throw err;
            }

            // remove pending (busy continua at√© checks verdes ou a√ß√£o do checks workflow)
            await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});

            const taskUrl = data?.metadata?.task_url || data?.task_url || "(sem task_url no payload)";

            await github.rest.issues.createComment({
              owner, repo,
              issue_number: info.prNumber,
              body: `ü§ñ **Manus Autopilot acionado por review bots (CodeRabbit + Codex)**\n- Task: ${taskUrl}\n- PR: ${prUrl}\n\n(Prote√ß√£o: label **${busyLabel}** ativa; debounce 15 min aplicado.)`
            }).catch(() => {});
