name: Manus Autopilot (CodeRabbit + Codex)

on:
  issue_comment:
    types: [created, edited]
  pull_request_review_comment:
    types: [created, edited]
  pull_request_review:
    types: [submitted, edited]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  autopilot:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Debounce 15m and trigger Manus only on actionable bot feedback
        uses: actions/github-script@v7
        env:
          MANUS_API_KEY: ${{ secrets.MANUS_API_KEY }}
          MANUS_PROJECT_ID: ${{ secrets.MANUS_PROJECT_ID }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const busyLabel = "manus-busy";
            const pendingLabel = "manus-feedback-pending";

            // SÃ³ esses bots disparam o autopilot (evita loop com comentÃ¡rios do Manus/humanos)
            const allowedBots = new Set([
              "coderabbitai",
              "coderabbitai[bot]",
              "chatgpt-codex-connector",
              "chatgpt-codex-connector[bot]"
            ]);

            function getEventInfo() {
              const p = context.payload;

              // issue_comment em PR
              if (p.comment && p.issue && p.issue.pull_request) {
                return {
                  prNumber: p.issue.number,
                  actor: p.comment.user?.login,
                  body: p.comment.body || "",
                  url: p.comment.html_url || ""
                };
              }

              // review comment (inline)
              if (p.comment && p.pull_request) {
                return {
                  prNumber: p.pull_request.number,
                  actor: p.comment.user?.login,
                  body: p.comment.body || "",
                  url: p.comment.html_url || ""
                };
              }

              // review (submitted/edited)
              if (p.review && p.pull_request) {
                return {
                  prNumber: p.pull_request.number,
                  actor: p.review.user?.login,
                  body: p.review.body || "",
                  url: p.review.html_url || ""
                };
              }

              return null;
            }

            function looksPlaceholder(text) {
              const t = (text || "").toLowerCase();
              const signals = [
                "reviewing",
                "i'm reviewing",
                "starting review",
                "in progress",
                "queued",
                "estou revisando",
                "analisando",
                "analyzing"
              ];
              // placeholder tÃ­pico Ã© curto
              return signals.some(s => t.includes(s)) && t.length < 500;
            }

            function looksActionable(text) {
              const t = (text || "").toLowerCase();
              if (!t.trim()) return false;
              if (looksPlaceholder(t)) return false;

              const actionableSignals = [
                "actionable",
                "requested changes",
                "must",
                "should",
                "fix",
                "bug",
                "security",
                "vulnerab",
                "error",
                "pre-merge",
                "nitpick",
                "finishing touches",
                "âš ",
                "âŒ"
              ];

              if (actionableSignals.some(s => t.includes(s))) return true;

              // Se Ã© review grande, assume actionable
              return t.length >= 800;
            }

            const info = getEventInfo();
            if (!info) {
              core.info("Evento nÃ£o associado a PR. Ignorando.");
              return;
            }

            if (!allowedBots.has(info.actor)) {
              core.info(`Autor ${info.actor} nÃ£o Ã© bot alvo. Ignorando.`);
              return;
            }

            // Evita disparar com placeholder: sÃ³ comeÃ§a o debounce se jÃ¡ parecer actionable
            if (!looksActionable(info.body)) {
              core.info("ComentÃ¡rio do bot nÃ£o parece actionable (ou Ã© placeholder). Aguardando comentÃ¡rios/ediÃ§Ãµes futuras.");
              return;
            }

            // Carrega PR
            const prResp = await github.rest.pulls.get({ owner, repo, pull_number: info.prNumber });
            const pr = prResp.data;

            const headRef = pr.head?.ref || "";
            if (!headRef.startsWith("manus/")) {
              core.info(`PR #${info.prNumber} nÃ£o Ã© manus/* (${headRef}). Ignorando.`);
              return;
            }

            if (pr.state !== "open" || pr.draft) {
              core.info(`PR #${info.prNumber} nÃ£o estÃ¡ pronto (state=${pr.state}, draft=${pr.draft}).`);
              return;
            }

            const labels = (pr.labels || []).map(l => l.name);

            if (labels.includes(busyLabel)) {
              core.info(`PR #${info.prNumber} jÃ¡ estÃ¡ ${busyLabel}. Ignorando.`);
              return;
            }

            if (labels.includes(pendingLabel)) {
              core.info(`PR #${info.prNumber} jÃ¡ estÃ¡ ${pendingLabel}. Ignorando para evitar duplicidade.`);
              return;
            }

            // Marca pending e espera 15 minutos para agregar feedback final
            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: info.prNumber,
              labels: [pendingLabel]
            }).catch(() => {});

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            core.info("Debounce: aguardando 15 minutos para agregar feedback final (CodeRabbit/Codex)...");
            await sleep(15 * 60 * 1000);

            // Recarrega PR
            const prResp2 = await github.rest.pulls.get({ owner, repo, pull_number: info.prNumber });
            const pr2 = prResp2.data;

            if (pr2.state !== "open" || pr2.draft) {
              core.info("PR fechada/draft apÃ³s debounce. Limpando pending e saindo.");
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            const labels2 = (pr2.labels || []).map(l => l.name);
            if (labels2.includes(busyLabel)) {
              core.info("PR ficou busy durante debounce. Limpando pending e saindo.");
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            // Coleta feedback recente (Ãºltimas 24h) de CodeRabbit + Codex
            async function collectBotFeedback(prNumber) {
              const sinceMs = Date.now() - (24 * 60 * 60 * 1000);
              const items = [];

              const issueComments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: prNumber, per_page: 100
              });

              for (const c of issueComments) {
                const login = c.user?.login;
                const created = new Date(c.created_at).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({ kind: "issue_comment", author: login, url: c.html_url, created_at: c.created_at, body: c.body || "" });
              }

              const reviewComments = await github.paginate(github.rest.pulls.listReviewComments, {
                owner, repo, pull_number: prNumber, per_page: 100
              });

              for (const c of reviewComments) {
                const login = c.user?.login;
                const created = new Date(c.created_at).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({ kind: "review_comment", author: login, url: c.html_url, created_at: c.created_at, body: c.body || "" });
              }

              const reviews = await github.paginate(github.rest.pulls.listReviews, {
                owner, repo, pull_number: prNumber, per_page: 100
              });

              for (const r of reviews) {
                const login = r.user?.login;
                const ts = r.submitted_at || r.created_at || new Date().toISOString();
                const created = new Date(ts).getTime();
                if (created < sinceMs) continue;
                if (!allowedBots.has(login)) continue;
                items.push({ kind: "review", author: login, url: r.html_url, created_at: ts, body: r.body || "" });
              }

              items.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
              return items.slice(-40);
            }

            const feedback = await collectBotFeedback(info.prNumber);

            // Confirma que existe algo actionable no agregado (proteÃ§Ã£o extra)
            const hasActionable = feedback.some(f => looksActionable(f.body));
            if (!hasActionable) {
              core.info("ApÃ³s debounce, nÃ£o hÃ¡ feedback actionable detectado. Limpando pending e saindo.");
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              return;
            }

            // Marca busy
            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: info.prNumber,
              labels: [busyLabel]
            }).catch(() => {});

            // Monta prompt agregando CodeRabbit + Codex e reforÃ§ando AGENTS.md
            const chunks = feedback.map((f, idx) => {
              const body = (f.body || "").replace(/\r/g, "");
              const clipped = body.length > 2400 ? body.slice(0, 2400) + "\n...(truncado)" : body;
              return [
                `### Feedback ${idx + 1} (${f.author} / ${f.kind})`,
                `Link: ${f.url}`,
                "",
                clipped
              ].join("\n");
            }).join("\n\n---\n\n");

            const prompt = [
              "VocÃª Ã© o agente Manus e hÃ¡ feedback ACTIONABLE de bots de review neste Pull Request.",
              "",
              "ANTES DE QUALQUER MUDANÃ‡A:",
              "- Leia o arquivo AGENTS.md na raiz do repositÃ³rio e siga todas as regras.",
              "",
              `RepositÃ³rio: ${owner}/${repo}`,
              `PR: ${pr2.html_url}`,
              `Branch: ${headRef}`,
              "",
              "IMPORTANTE:",
              "- Considere TODO o feedback de CodeRabbit e ChatGPT Codex.",
              "- Mesmo que o resumo abaixo esteja incompleto, leia TODAS as threads/comentÃ¡rios no PR.",
              "",
              "Feedback agregado (Ãºltimas 24h):",
              chunks,
              "",
              "Tarefa:",
              "1) Ler TODO o feedback no PR (todas as threads e comentÃ¡rios), incluindo CodeRabbit + Codex.",
              "2) Implementar as mudanÃ§as necessÃ¡rias com o MENOR patch possÃ­vel.",
              `3) Fazer push na MESMA branch do PR (${headRef}).`,
              "4) Garantir CI/CodeQL verdes (se quebrar, conserte).",
              "5) NÃƒO fazer merge.",
              "",
              "Ao finalizar, comentar no PR:",
              "- o que foi feito",
              "- por que foi feito",
              "- como validar."
            ].join("\n");

            const body = {
              prompt,
              agentProfile: "manus-1.6",
              taskMode: "agent",
              interactiveMode: false
            };

            if (process.env.MANUS_PROJECT_ID) body.projectId = process.env.MANUS_PROJECT_ID;

            let data;
            try {
              const res = await fetch("https://api.manus.ai/v1/tasks", {
                method: "POST",
                headers: {
                  "API_KEY": process.env.MANUS_API_KEY,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });

              if (!res.ok) {
                const text = await res.text();
                throw new Error(`Manus API error: ${res.status} ${text}`);
              }

              data = await res.json();
            } catch (err) {
              // rollback para nÃ£o travar PR
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: busyLabel }).catch(() => {});
              await github.rest.issues.removeLabel({ owner, repo, issue_number: info.prNumber, name: pendingLabel }).catch(() => {});
              throw err;
            }

            // remove pending (busy continua atÃ© checks verdes removerem)
            await github.rest.issues.removeLabel({
              owner, repo,
              issue_number: info.prNumber,
              name: pendingLabel
            }).catch(() => {});

            const taskUrl = data?.metadata?.task_url || data?.task_url || "(sem task_url no payload)";

            await github.rest.issues.createComment({
              owner, repo,
              issue_number: info.prNumber,
              body: `ðŸ¤– **Manus Autopilot acionado por review bots (CodeRabbit + Codex)**\n- Task: ${taskUrl}\n\n(ProteÃ§Ã£o: label **${busyLabel}** ativa; debounce 15 min aplicado.)`
            }).catch(() => {});
