name: Manus Autopilot (coderabbit)

on:
  pull_request_review:
    types: [submitted, edited]
  pull_request_review_comment:
    types: [created, edited]
  issue_comment:
    types: [created, edited]

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  autopilot:
    runs-on: ubuntu-latest

    steps:
      - name: Trigger Manus when CodeRabbit leaves feedback
        uses: actions/github-script@v7
        env:
          MANUS_API_KEY: ${{ secrets.MANUS_API_KEY }}
          MANUS_PROJECT_ID: ${{ secrets.MANUS_PROJECT_ID }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const busyLabel = "manus-busy";
            const pendingLabel = "manus-pending";

            let prNumber = null;
            let feedbackUrl = null;
            let author = null;
            let feedbackText = "";

            // -------------------------------
            // Helper: detect if it's REAL feedback (not "reviewing..." placeholder)
            // -------------------------------
            function isSubstantiveCodeRabbitFeedback(text) {
              if (!text) return false;

              const raw = String(text).trim();
              if (raw.length < 120) return false; // muito curto costuma ser "estou revisando"

              const t = raw.toLowerCase();

              // Marcadores tÃ­picos de review pronto do CodeRabbit
              const strongMarkers = [
                "walkthrough",
                "pre-merge checks",
                "finishing touches",
                "recent review details",
                "recent nitpick comments",
                "review completed"
              ];

              const hasStrongMarker = strongMarkers.some(m => t.includes(m));

              // Se for placeholder / "review em andamento"
              const placeholderPatterns = [
                /review in progress/i,
                /i['â€™]?m reviewing/i,
                /starting (my )?review/i,
                /generating review/i,
                /analyzing/i,
                /please wait/i
              ];

              const looksPlaceholder = placeholderPatterns.some(re => re.test(raw));

              // Sinais adicionais que geralmente aparecem num review final
              const hasSignals =
                raw.includes("âœ…") ||
                raw.includes("âŒ") ||
                t.includes("suggestion") ||
                t.includes("nitpick") ||
                t.includes("issue") ||
                t.includes("warning") ||
                t.includes("error");

              // Regra final:
              // - Aceita se tiver marker forte
              // - ou se tiver sinais e for bem longo
              // - rejeita se parece placeholder e nÃ£o tem marker forte
              if (looksPlaceholder && !hasStrongMarker) return false;

              return hasStrongMarker || (hasSignals && raw.length >= 200);
            }

            // -------------------------------
            // Identify PR / feedback by event type
            // -------------------------------
            if (context.eventName === "pull_request_review") {
              prNumber = context.payload.pull_request.number;
              feedbackUrl = context.payload.review.html_url;
              author = context.payload.review.user?.login;
              feedbackText = (context.payload.review.body || "").trim();
            } else if (context.eventName === "pull_request_review_comment") {
              prNumber = context.payload.pull_request.number;
              feedbackUrl = context.payload.comment.html_url;
              author = context.payload.comment.user?.login;
              feedbackText = (context.payload.comment.body || "").trim();
            } else if (context.eventName === "issue_comment") {
              if (!context.payload.issue.pull_request) {
                core.info("issue_comment nÃ£o Ã© PR. Ignorando.");
                return;
              }
              prNumber = context.payload.issue.number;
              feedbackUrl = context.payload.comment.html_url;
              author = context.payload.comment.user?.login;
              feedbackText = (context.payload.comment.body || "").trim();
            } else {
              return;
            }

            // filtro do CodeRabbit
            const login = (author || "").toLowerCase();
            const isCodeRabbit =
              login === "coderabbitai" ||
              login === "coderabbitai[bot]" ||
              login.includes("coderabbit");

            if (!isCodeRabbit) {
              core.info(`Ignorando autor: ${author}`);
              return;
            }

            // ignora placeholder/preview de review
            if (!isSubstantiveCodeRabbitFeedback(feedbackText)) {
              core.info(
                `Feedback do CodeRabbit detectado, mas parece placeholder/incompleto. Ignorando por enquanto. Event=${context.eventName}`
              );
              return;
            }

            // carrega PR
            const prResp = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const pr = prResp.data;

            // filtro por branch manus/*
            const headRef = pr.head?.ref || "";
            if (!headRef.startsWith("manus/")) {
              core.info(`Not a manus branch (${headRef}). Exiting.`);
              return;
            }

            // PR precisa estar aberto e nÃ£o draft
            if (pr.state !== "open" || pr.draft) {
              core.info(`PR #${prNumber} nÃ£o estÃ¡ pronto (state=${pr.state}, draft=${pr.draft}).`);
              return;
            }

            const labels = (pr.labels || []).map(l => l.name);

            // busy lock: se busy, marca pending (fila) e sai
            if (labels.includes(busyLabel)) {
              if (!labels.includes(pendingLabel)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: prNumber,
                  labels: [pendingLabel]
                }).catch(() => {});
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `ðŸ“Œ Novo feedback do CodeRabbit chegou enquanto o Manus estÃ¡ **busy**.\nVou processar depois via label **${pendingLabel}**.\nLink: ${feedbackUrl}`
              }).catch(() => {});

              core.info(`PR #${prNumber} busy -> enfileirado com ${pendingLabel}.`);
              return;
            }

            if (!process.env.MANUS_API_KEY) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `âš ï¸ Manus Autopilot nÃ£o pÃ´de ser acionado porque **MANUS_API_KEY** nÃ£o estÃ¡ configurada nos Secrets.`
              }).catch(() => {});
              return;
            }

            // marca busy
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: [busyLabel]
            }).catch(() => {});

            // monta prompt
            const promptLines = [
              "VocÃª Ã© o agente Manus trabalhando neste repositÃ³rio e hÃ¡ novo feedback do CodeRabbit.",
              "",
              `RepositÃ³rio: ${owner}/${repo}`,
              `PR: ${pr.html_url}`,
              `Branch: ${headRef}`,
              `Evento: ${context.eventName}`,
              `Feedback link: ${feedbackUrl}`,
              "",
              "ConteÃºdo do feedback (texto):",
              "```",
              feedbackText,
              "```",
              "",
              "Tarefa:",
              "1) Ler o feedback completo do CodeRabbit no PR (threads inclusive).",
              "2) Aplicar correÃ§Ãµes/melhorias sugeridas que fizerem sentido.",
              `3) Fazer push na MESMA branch do PR (${headRef}).`,
              "4) Garantir CI/CodeQL verdes (se quebrar, conserte).",
              "5) NÃƒO fazer merge.",
              "",
              "Ao finalizar, comentar no PR:",
              "- o que foi feito",
              "- por que foi feito",
              "- como validar."
            ];

            const prompt = promptLines.join("\n");

            const bodyPayload = {
              prompt,
              agentProfile: "manus-1.6",
              taskMode: "agent",
              interactiveMode: false
            };

            if (process.env.MANUS_PROJECT_ID) {
              bodyPayload.projectId = process.env.MANUS_PROJECT_ID; // camelCase CORRETO
            }

            try {
              const res = await fetch("https://api.manus.ai/v1/tasks", {
                method: "POST",
                headers: {
                  "API_KEY": process.env.MANUS_API_KEY,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(bodyPayload)
              });

              if (!res.ok) {
                const text = await res.text();

                // remove busy se falhou criar task
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name: busyLabel
                }).catch(() => {});

                throw new Error(`Manus API error: ${res.status} ${text}`);
              }

              const data = await res.json();

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `ðŸ¤– **Manus Autopilot acionado por feedback do CodeRabbit** (${context.eventName}).\nTask: ${data.task_url || "(task_url nÃ£o retornado)"}\n(Label **${busyLabel}** ativa para evitar tasks duplicadas.)`
              }).catch(() => {});

              core.info(`Manus task criada para PR #${prNumber} via CodeRabbit.`);
            } catch (err) {
              core.warning(`Erro ao acionar Manus no PR #${prNumber}: ${String(err?.message || err)}`);
              throw err;
            }
