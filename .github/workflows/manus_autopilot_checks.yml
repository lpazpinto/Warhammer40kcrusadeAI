name: Manus Autopilot (checks)

on:
  workflow_run:
    workflows: ["CI", "CodeQL"]
    types: [completed]

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  autopilot:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Manus on failure / clear busy on success (SHA fallback)
        uses: actions/github-script@v7
        env:
          MANUS_API_KEY: ${{ secrets.MANUS_API_KEY }}
          MANUS_PROJECT_ID: ${{ secrets.MANUS_PROJECT_ID }}
        with:
          script: |
            const run = context.payload.workflow_run;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (run.event !== "pull_request") {
              core.info(`Ignorando workflow_run (event=${run.event}).`);
              return;
            }

            async function getAssociatedPRNumbers() {
              const prs = run.pull_requests || [];
              if (prs.length > 0) return prs.map(p => p.number);

              const sha = run.head_sha;
              if (!sha) return [];

              try {
                const { data } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: sha,
                  mediaType: { previews: ["groot"] }
                });

                return (data || []).map(pr => pr.number);
              } catch (e) {
                core.warning(`Falha ao buscar PR por SHA (${sha}): ${String(e?.message || e)}`);
                return [];
              }
            }

            const prNumbers = await getAssociatedPRNumbers();

            if (prNumbers.length === 0) {
              core.info("Nenhum PR associado a este workflow_run (nem por SHA).");
              return;
            }

            const busyLabel = "manus-busy";
            const isSuccess = run.conclusion === "success";
            const isFailureLike = new Set(["failure", "cancelled", "timed_out", "action_required"]);

            if (!isSuccess && !isFailureLike.has(run.conclusion)) {
              core.info(`Conclus√£o ${run.conclusion} n√£o aciona autopilot.`);
              return;
            }

            for (const prNumber of prNumbers) {
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

              const headRef = pr.data.head.ref || "";
              const state = pr.data.state;
              const draft = pr.data.draft;

              if (!headRef.startsWith("manus/")) {
                core.info(`PR #${prNumber} n√£o √© manus/* (${headRef}). Ignorando.`);
                continue;
              }

              if (state !== "open" || draft) {
                core.info(`PR #${prNumber} n√£o est√° aberto ou √© draft. Ignorando.`);
                continue;
              }

              const labels = (pr.data.labels || []).map(l => l.name);

              if (isSuccess) {
                if (labels.includes(busyLabel)) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: prNumber,
                    name: busyLabel
                  }).catch(() => {});

                  await github.rest.issues.createComment({
                    owner, repo, issue_number: prNumber,
                    body: `‚úÖ Checks passaram (${run.name}). Label **${busyLabel}** removida. Autopilot liberado.\nRun: ${run.html_url}`
                  }).catch(() => {});
                }
                continue;
              }

              // failure: se j√° est√° busy, n√£o dispara de novo
              if (labels.includes(busyLabel)) {
                core.info(`PR #${prNumber} j√° est√° busy (${busyLabel}).`);
                continue;
              }

              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber,
                labels: [busyLabel]
              });

              const promptLines = [
                "Voc√™ √© o agente Manus respons√°vel por corrigir falhas de CI/CodeQL neste reposit√≥rio.",
                "",
                `Reposit√≥rio: ${owner}/${repo}`,
                `Pull Request: ${pr.data.html_url}`,
                `Branch do PR: ${headRef}`,
                "",
                "Falha detectada:",
                `- Workflow: ${run.name}`,
                `- Conclus√£o: ${run.conclusion}`,
                `- Run: ${run.html_url}`,
                `- SHA: ${run.head_sha}`,
                "",
                "Objetivo:",
                "1) Abrir o link do Run e identificar o PRIMEIRO step que falhou.",
                "2) Corrigir com o MENOR patch poss√≠vel.",
                `3) Fazer push na MESMA branch do PR: ${headRef}`,
                "4) N√ÉO fazer merge.",
                "5) Repetir at√© ficar tudo verde (CI + CodeQL).",
                "",
                "Regra: se for problema de ambiente/depend√™ncia, N√ÉO invente. Comente no PR e pare.",
                "",
                "Ao finalizar, comentar no PR:",
                "- causa raiz (1‚Äì2 linhas)",
                "- arquivos alterados",
                "- como validar"
              ];

              const body = {
                prompt: promptLines.join("\n"),
                agentProfile: "manus-1.6",
                taskMode: "agent",
                interactiveMode: false
              };

              if (process.env.MANUS_PROJECT_ID) body.projectId = process.env.MANUS_PROJECT_ID;

              const res = await fetch("https://api.manus.ai/v1/tasks", {
                method: "POST",
                headers: {
                  "API_KEY": process.env.MANUS_API_KEY,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });

              if (!res.ok) {
                throw new Error(`Manus API error: ${res.status} ${await res.text()}`);
              }

              const data = await res.json();

              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `ü§ñ **Manus Autopilot acionado**: **${run.name}** falhou.\n- Task: ${data.task_url}\n- Run: ${run.html_url}\n\n(Label **${busyLabel}** adicionada para evitar tasks duplicadas.)`
              });
